# Proxy-WASM-compatible shared-memory interface

* Status: proposed
* Deciders: WasmX
* Date: 2022-08-04

## Table of Contents

- [Table of Contents](#table-of-contents)
- [Problem Statement](#problem-statement)
- [Technical Context](#technical-context)
- [Decision Drivers](#decision-drivers)
- [Proposal](#proposal)
  - [Internal ABI](#internal-abi)
    - [Shared memory zone: `ngx_wasm_shm_t`, `ngx_wasm_shm_group_t`](#shared-memory-zone-ngx_wasm_shm_t-ngx_wasm_shm_group_t)
    - [Shared memory family: `ngx_wasm_shm_family_t`](#shared-memory-family-ngx_wasm_shm_family_t)
    - [KV methods](#kv-methods)
  - [Underlying mechanisms](#underlying-mechanisms)
    - [Circular buffer](#circular-buffer)
    - [Futex on counter](#futex-on-counter)
    - [Per-worker dispatch thread](#per-worker-dispatch-thread)
  - [Known Limitations](#known-limitations)
- [Decision Outcomes](#decision-outcomes)

## Problem Statement

Nginx is a multi-process system where there is one *master* process and multiple *worker* processes. There is a need to share data and communicate between WebAssembly plugin instances in different worker processes, but it is not currently possible to pass data across the process boundary in WasmX.

The goal of this proposal is to design WasmX's internal ABI and mechanisms for implementing the key-value store and queue API as defined by the proxy-wasm specification, based on the [Nginx shared memory API](http://nginx.org/en/docs/dev/development_guide.html#shared_memory).

[Back to TOC](#table-of-contents)

## Technical Context

In the OpenResty Lua API there is the [shdict](https://github.com/openresty/lua-resty-core/blob/master/lib/resty/core/shdict.lua) module that provides a cross-process communication mechanism to plugins written in Lua. The design in proxy-wasm is similar, in the form of *shared kv stores* and *shared queues*.

On the surface, this is the set of ABI functions defined by proxy-wasm:

```cpp
extern "C" WasmResult proxy_get_shared_data(const char *key_ptr, size_t key_size,
                                            const char **value_ptr, size_t *value_size,
                                            uint32_t *cas);
extern "C" WasmResult proxy_set_shared_data(const char *key_ptr, size_t key_size,
                                            const char *value_ptr, size_t value_size, uint32_t cas);
extern "C" WasmResult proxy_register_shared_queue(const char *queue_name_ptr,
                                                  size_t queue_name_size, uint32_t *token);
extern "C" WasmResult proxy_resolve_shared_queue(const char *vm_id, size_t vm_id_size,
                                                 const char *queue_name_ptr, size_t queue_name_size,
                                                 uint32_t *token);
extern "C" WasmResult proxy_dequeue_shared_queue(uint32_t token, const char **data_ptr,
                                                 size_t *data_size);
extern "C" WasmResult proxy_enqueue_shared_queue(uint32_t token, const char *data_ptr,
                                                 size_t data_size);
```

And the WASM plugin can provide a function to be woke up when a new message arrives in the queue:

```cpp
extern "C" void proxy_on_queue_ready(uint32_t root_context_id, uint32_t token);
```

The KV store ABI supports single-key transactions with the `cas` parameter. The shared queue ABI exposes a simple pair of enqueue/dequeue functions, without specifying behavior on edge-cases like a full queue.

[Back to TOC](#table-of-contents)

## Decision Drivers

- Aim at `proxy-wasm` full compatibility.
- Have a internal shared memory ABI that is independent from `proxy-wasm`.

[Back to TOC](#table-of-contents)

## Proposal

Overview TBD

### Internal ABI

#### Shared memory zone: `ngx_wasm_shm_t`, `ngx_wasm_shm_group_t`

An `ngx_wasm_shm_t` is stored in the `data` field of an `ngx_shm_zone_t`.

```c
typedef enum {
    NGX_WASM_SHM_TYPE_KV = 0,
    NGX_WASM_SHM_TYPE_QUEUE = 1,
} ngx_wasm_shm_type_e;

struct ngx_wasm_shm_s {
    ngx_wasm_shm_type_e     type;
    ngx_slab_pool_t        *shpool;
    ngx_str_t               name;
    uint32_t               *notification; // array(max_num_workers)
};

typedef struct ngx_wasm_shm_s ngx_wasm_shm_t;
```

#### Shared memory family: `ngx_wasm_shm_family_t`

A shared memory family `ngx_wasm_shm_family_t` is a mapping from name to `ngx_shm_zone_t`. It is stored as a field in `ngx_wasm_core_conf_t` and initialized during config load.

```c
struct ngx_wasm_shm_family_s {
    ngx_list_t *head;
};

typedef struct ngx_wasm_shm_family_s ngx_wasm_shm_family_t;

struct ngx_wasm_shm_family_mapping_s {
    ngx_str_t name;
    ngx_shm_zone_t *zone;
};
```

#### KV methods

TBD.

```c
void ngx_wasm_shm_kv_get(const char *key_ptr, size_t key_size,
                         const char **value_ptr, size_t *value_size,
                         uint32_t *cas);
void ngx_wasm_shm_kv_set(const char *key_ptr, size_t key_size,
                         const char *value_ptr, size_t *value_size,
                         uint32_t cas);
```

### Underlying mechanisms

To implement all the proxy-wasm ABI functions as described in the [technical context](#technical-context), the shared memory subsystem needs to serve two purposes: **synchronized data access** for storing and accessing the key-value pairs and enqueued messages, and **event notification** for invoking the `proxy_on_queue_ready` function.

A red-black tree will be used for storing the key-value pairs. Access to the red-black tree is synchronized using a global mutex. This part will be similar to [what OpenResty does](https://github.com/openresty/lua-nginx-module/blob/653d6a36f46b077cb902d7ba40824c299cf9bbf4/src/ngx_http_lua_shdict.c).

The shared queue part is more interesting, as it requires the ability to *notify* another worker asynchronously. The design is proposed as follows.

#### Circular buffer

A queue is a circular buffer of bytes. Each message consists of a 4-byte little-endian length header and the message body, in that order. Enqueue and dequeue operations correspond to push and pop on the circular buffer.

#### Futex on counter

Futex (fast user-space mutex) is an efficient mechanism for cross-process notification, and is supported on all mainstream platforms including Linux ([futex](https://man7.org/linux/man-pages/man2/futex.2.html)), macOS ([ulock](https://opensource.apple.com/source/xnu/xnu-7195.50.7.100.1/bsd/sys/ulock.h.auto.html)) and Windows ([WaitOnAddress](https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitonaddress)). In this proposal, futex will be used as the mechanism for notifying another worker about queue readiness.

Details TBD.

#### Per-worker dispatch thread

Each worker process spawns a *dispatch thread* on start. This dispatch thread is responsible for converting synchronous futex notifications to asynchronous `ngx_post_event` calls.

Details TBD.

[Back to TOC](#table-of-contents)

### Known Limitations

TBD.

[Back to TOC](#table-of-contents)

## Decision Outcomes

TBD.

[Back to TOC](#table-of-contents)
